{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nvar _excluded = [\"id\", \"otherId\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport { SharedElementCompatRouteProxy } from \"./SharedElementCompatRouteProxy\";\nimport { normalizeSharedElementsConfig } from \"./utils\";\n\nfunction getSharedElements(scene, otherScene, showing) {\n  var sharedElements = scene.getSharedElements();\n  if (!sharedElements) return null;\n  return normalizeSharedElementsConfig(sharedElements(new SharedElementCompatRouteProxy(scene.route), new SharedElementCompatRouteProxy(otherScene.route), showing));\n}\n\nvar NO_SHARED_ELEMENTS = [];\n\nvar SharedElementRendererData = function () {\n  function SharedElementRendererData() {\n    _classCallCheck(this, SharedElementRendererData);\n\n    this.scenes = [];\n    this.updateSubscribers = new Set();\n    this.sharedElements = null;\n    this.isShowing = true;\n    this.route = null;\n    this.prevRoute = null;\n    this.scene = null;\n    this.prevScene = null;\n    this.isTransitionStarted = false;\n    this.isTransitionClosing = false;\n    this.transitionNavigatorId = \"\";\n    this.transitionNestingDepth = -1;\n    this.debugRefCount = 0;\n  }\n\n  _createClass(SharedElementRendererData, [{\n    key: \"startTransition\",\n    value: function startTransition(closing, navigatorId, nestingDepth) {\n      if (this.debug) console.debug(\"[\" + navigatorId + \"]startTransition, closing: \" + closing + \", nestingDepth: \" + nestingDepth);\n\n      if (!this.isTransitionStarted || this.route) {\n        this.prevRoute = this.route;\n        this.route = null;\n        this.routeAnimValue = null;\n\n        if (this.isTransitionStarted) {\n          var scene = this.getScene(this.prevRoute);\n\n          if (scene) {\n            this.routeAnimValue = scene.getAnimValue(true);\n          }\n        }\n\n        this.isTransitionStarted = true;\n        this.isTransitionClosing = closing;\n        this.transitionNavigatorId = navigatorId;\n        this.transitionNestingDepth = nestingDepth;\n      } else {\n        if (nestingDepth < this.transitionNestingDepth) {\n          this.transitionNavigatorId = navigatorId;\n          this.transitionNestingDepth = nestingDepth;\n        }\n      }\n    }\n  }, {\n    key: \"endTransition\",\n    value: function endTransition(closing, navigatorId, nestingDepth) {\n      if (this.debug) console.debug(\"[\" + navigatorId + \"]endTransition, closing: \" + closing + \", nestingDepth: \" + nestingDepth);\n\n      if (!this.isTransitionStarted || this.transitionNavigatorId !== navigatorId) {\n        return;\n      }\n\n      this.isTransitionStarted = false;\n\n      if (this.prevRoute != null) {\n        this.prevRoute = null;\n        this.routeAnimValue = null;\n        this.updateSceneListeners();\n        this.updateSharedElements();\n      }\n    }\n  }, {\n    key: \"updateSceneState\",\n    value: function updateSceneState(scene, eventType) {\n      switch (eventType) {\n        case \"willFocus\":\n          return this.willFocusScene(scene);\n\n        case \"didFocus\":\n          return this.didFocusScene(scene);\n      }\n    }\n  }, {\n    key: \"addDebugRef\",\n    value: function addDebugRef() {\n      return ++this.debugRefCount;\n    }\n  }, {\n    key: \"releaseDebugRef\",\n    value: function releaseDebugRef() {\n      return --this.debugRefCount;\n    }\n  }, {\n    key: \"debug\",\n    get: function get() {\n      return this.debugRefCount > 0;\n    }\n  }, {\n    key: \"willFocusScene\",\n    value: function willFocusScene(scene) {\n      if (this.debug) console.debug(\"[\" + scene.navigatorId + \"]willFocus, scene: \\\"\" + scene.name + \"\\\", depth: \" + scene.nestingDepth + \", closing: \" + this.isTransitionClosing);\n      this.registerScene(scene);\n      if (!this.isTransitionStarted) return;\n\n      if (this.prevRoute) {\n        var routeScene = this.isTransitionClosing ? this.getScene(this.prevRoute) : scene;\n\n        if ((routeScene == null ? void 0 : routeScene.navigatorId) === this.transitionNavigatorId) {\n          this.routeAnimValue = routeScene == null ? void 0 : routeScene.getAnimValue(this.isTransitionClosing);\n        }\n      }\n\n      if (!this.route) {\n        this.route = scene.route;\n      } else {\n        var _routeScene = this.getScene(this.route);\n\n        if (_routeScene && _routeScene.nestingDepth <= scene.nestingDepth) {\n          this.route = scene.route;\n        }\n      }\n\n      if (this.prevRoute && this.route && this.routeAnimValue) {\n        this.updateSceneListeners();\n        this.updateSharedElements();\n      }\n    }\n  }, {\n    key: \"didFocusScene\",\n    value: function didFocusScene(scene) {\n      if (this.debug) console.debug(\"[\" + scene.navigatorId + \"]didFocus, scene: \\\"\" + scene.name + \"\\\", depth: \" + scene.nestingDepth);\n\n      if (!this.route || this.prevRoute) {\n        this.route = scene.route;\n      } else {\n        var routeScene = this.getScene(this.route);\n\n        if (routeScene && routeScene.nestingDepth <= scene.nestingDepth) {\n          this.route = scene.route;\n        }\n      }\n\n      this.registerScene(scene);\n    }\n  }, {\n    key: \"registerScene\",\n    value: function registerScene(scene) {\n      this.scenes.push({\n        scene: scene,\n        subscription: null\n      });\n\n      if (this.scenes.length > 10) {\n        var subscription = this.scenes[0].subscription;\n        this.scenes.splice(0, 1);\n        subscription == null ? void 0 : subscription();\n      }\n\n      this.updateSceneListeners();\n    }\n  }, {\n    key: \"updateSceneListeners\",\n    value: function updateSceneListeners() {\n      var _this = this;\n\n      this.scenes.forEach(function (sceneRoute) {\n        var scene = sceneRoute.scene,\n            subscription = sceneRoute.subscription;\n        var isActive = _this.route && _this.route.key === scene.route.key || _this.prevRoute && _this.prevRoute.key === scene.route.key;\n\n        if (isActive && !subscription) {\n          sceneRoute.subscription = scene.addUpdateListener(function () {\n            _this.emitUpdateEvent();\n          });\n        } else if (!isActive && subscription) {\n          sceneRoute.subscription = null;\n          subscription();\n        }\n      });\n    }\n  }, {\n    key: \"getScene\",\n    value: function getScene(route) {\n      var sceneRoute = route ? this.scenes.find(function (sc) {\n        return sc.scene.route.key === route.key;\n      }) : undefined;\n      return sceneRoute ? sceneRoute.scene : null;\n    }\n  }, {\n    key: \"updateSharedElements\",\n    value: function updateSharedElements() {\n      var route = this.route,\n          prevRoute = this.prevRoute,\n          routeAnimValue = this.routeAnimValue;\n      var scene = this.getScene(route);\n      var prevScene = this.getScene(prevRoute);\n      var sceneAnimValue = routeAnimValue;\n      if (scene === this.scene && prevScene === this.prevScene && sceneAnimValue === this.sceneAnimValue) return;\n      this.scene = scene;\n      this.prevScene = prevScene;\n      this.sceneAnimValue = sceneAnimValue;\n      var sharedElements = null;\n      var isShowing = true;\n\n      if (sceneAnimValue && scene && prevScene && route && prevRoute) {\n        sharedElements = getSharedElements(scene, prevScene, true);\n\n        if (!sharedElements) {\n          isShowing = false;\n          sharedElements = getSharedElements(prevScene, scene, false);\n        }\n      }\n\n      if (this.sharedElements !== sharedElements) {\n        if (this.debug) {\n          if (sharedElements) {\n            console.debug(\"Transition start: \\\"\" + (prevScene == null ? void 0 : prevScene.name) + \"\\\" -> \\\"\" + (scene == null ? void 0 : scene.name) + \"\\\", elements: \" + JSON.stringify(sharedElements, undefined, 2));\n          } else {\n            console.debug(\"Transition end: \\\"\" + (scene == null ? void 0 : scene.name) + \"\\\"\");\n          }\n        }\n\n        this.sharedElements = sharedElements;\n        this.isShowing = isShowing;\n        this.emitUpdateEvent();\n      }\n    }\n  }, {\n    key: \"addUpdateListener\",\n    value: function addUpdateListener(handler) {\n      var _this2 = this;\n\n      this.updateSubscribers.add(handler);\n      return function () {\n        return _this2.updateSubscribers.delete(handler);\n      };\n    }\n  }, {\n    key: \"emitUpdateEvent\",\n    value: function emitUpdateEvent() {\n      this.updateSubscribers.forEach(function (handler) {\n        return handler();\n      });\n    }\n  }, {\n    key: \"getTransitions\",\n    value: function getTransitions() {\n      var sharedElements = this.sharedElements,\n          prevScene = this.prevScene,\n          scene = this.scene,\n          isShowing = this.isShowing,\n          sceneAnimValue = this.sceneAnimValue;\n      if (!sharedElements || !scene || !prevScene) return NO_SHARED_ELEMENTS;\n      return sharedElements.map(function (_ref) {\n        var id = _ref.id,\n            otherId = _ref.otherId,\n            other = _objectWithoutProperties(_ref, _excluded);\n\n        var startId = isShowing ? otherId || id : id;\n        var endId = isShowing ? id : otherId || id;\n        return _objectSpread({\n          key: scene.route.key,\n          position: sceneAnimValue,\n          start: {\n            ancestor: (prevScene ? prevScene.getAncestor() : undefined) || null,\n            node: (prevScene ? prevScene.getNode(startId) : undefined) || null\n          },\n          end: {\n            ancestor: (scene ? scene.getAncestor() : undefined) || null,\n            node: (scene ? scene.getNode(endId) : undefined) || null\n          }\n        }, other);\n      });\n    }\n  }, {\n    key: \"nestingDepth\",\n    get: function get() {\n      return 0;\n    }\n  }]);\n\n  return SharedElementRendererData;\n}();\n\nexport { SharedElementRendererData as default };","map":{"version":3,"sources":["../src/SharedElementRendererData.ts"],"names":[],"mappings":"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","sourcesContent":["import { SharedElementCompatRouteProxy } from \"./SharedElementCompatRouteProxy\";\nimport SharedElementSceneData, {\n  SharedElementSceneEventType,\n} from \"./SharedElementSceneData\";\nimport {\n  SharedElementEventSubscription,\n  SharedElementsStrictConfig,\n  SharedElementAnimatedValue,\n  SharedElementTransitionProps,\n  SharedElementRoute,\n} from \"./types\";\nimport { normalizeSharedElementsConfig } from \"./utils\";\n\nexport type SharedElementRendererUpdateHandler = () => any;\n\nexport interface ISharedElementRendererData {\n  startTransition(\n    closing: boolean,\n    navigatorId: string,\n    nestingDepth: number\n  ): void;\n  endTransition(\n    closing: boolean,\n    navigatorId: string,\n    nestingDepth: number\n  ): void;\n  updateSceneState(\n    scene: SharedElementSceneData,\n    eventType: SharedElementSceneEventType\n  ): void;\n  readonly nestingDepth: number;\n  addDebugRef(): number;\n  releaseDebugRef(): number;\n}\n\nfunction getSharedElements(\n  scene: SharedElementSceneData,\n  otherScene: SharedElementSceneData,\n  showing: boolean\n): SharedElementsStrictConfig | null {\n  const sharedElements = scene.getSharedElements();\n  if (!sharedElements) return null;\n  return normalizeSharedElementsConfig(\n    sharedElements(\n      new SharedElementCompatRouteProxy(scene.route),\n      new SharedElementCompatRouteProxy(otherScene.route),\n      showing\n    )\n  );\n}\n\nconst NO_SHARED_ELEMENTS: any[] = [];\n\ntype SceneRoute = {\n  scene: SharedElementSceneData;\n  subscription: SharedElementEventSubscription | null;\n};\n\n/**\n * TODO\n * - [ ] Not all lifecycle events not emitted by stack when using gestures (close modal)\n */\n\nexport default class SharedElementRendererData\n  implements ISharedElementRendererData\n{\n  private scenes: SceneRoute[] = [];\n  private updateSubscribers = new Set<SharedElementRendererUpdateHandler>();\n  private sharedElements: SharedElementsStrictConfig | null = null;\n  private isShowing: boolean = true;\n\n  private route: SharedElementRoute | null = null;\n  private prevRoute: SharedElementRoute | null = null;\n  private routeAnimValue: SharedElementAnimatedValue;\n\n  private scene: SharedElementSceneData | null = null;\n  private prevScene: SharedElementSceneData | null = null;\n  private sceneAnimValue: SharedElementAnimatedValue;\n\n  private isTransitionStarted: boolean = false;\n  private isTransitionClosing: boolean = false;\n  private transitionNavigatorId: string = \"\";\n  private transitionNestingDepth: number = -1;\n\n  public debugRefCount: number = 0;\n\n  startTransition(closing: boolean, navigatorId: string, nestingDepth: number) {\n    if (this.debug)\n      console.debug(\n        `[${navigatorId}]startTransition, closing: ${closing}, nestingDepth: ${nestingDepth}`\n      );\n\n    if (!this.isTransitionStarted || this.route) {\n      this.prevRoute = this.route;\n      this.route = null;\n      this.routeAnimValue = null;\n\n      // When a transition wasn't completely fully, but a new transition\n      // has already started, then the `willBlur` event is not called.\n      // For this particular case, we capture the animation-value of the\n      // last (previous) scene that is now being hidden.\n      if (this.isTransitionStarted) {\n        const scene = this.getScene(this.prevRoute);\n        if (scene) {\n          this.routeAnimValue = scene.getAnimValue(true);\n        }\n      }\n\n      this.isTransitionStarted = true;\n      this.isTransitionClosing = closing;\n      this.transitionNavigatorId = navigatorId;\n      this.transitionNestingDepth = nestingDepth;\n    } else {\n      // When navigators are nested, `startTransition` may be called multiple\n      // times. In such as case, we want to use the most shallow navigator,\n      // as that is the one doing the transition.\n      if (nestingDepth < this.transitionNestingDepth) {\n        this.transitionNavigatorId = navigatorId;\n        this.transitionNestingDepth = nestingDepth;\n      }\n    }\n  }\n\n  endTransition(closing: boolean, navigatorId: string, nestingDepth: number) {\n    if (this.debug)\n      console.debug(\n        `[${navigatorId}]endTransition, closing: ${closing}, nestingDepth: ${nestingDepth}`\n      );\n\n    if (\n      !this.isTransitionStarted ||\n      this.transitionNavigatorId !== navigatorId\n    ) {\n      return;\n    }\n\n    this.isTransitionStarted = false;\n\n    if (this.prevRoute != null) {\n      this.prevRoute = null;\n      this.routeAnimValue = null;\n      this.updateSceneListeners();\n      this.updateSharedElements();\n    }\n  }\n\n  updateSceneState(\n    scene: SharedElementSceneData,\n    eventType: SharedElementSceneEventType\n  ): void {\n    switch (eventType) {\n      case \"willFocus\":\n        return this.willFocusScene(scene);\n      case \"didFocus\":\n        return this.didFocusScene(scene);\n      /*case \"willBlur\":\n        return this.willBlurScene(scene);*/\n    }\n  }\n\n  addDebugRef(): number {\n    return ++this.debugRefCount;\n  }\n\n  releaseDebugRef(): number {\n    return --this.debugRefCount;\n  }\n\n  get debug() {\n    return this.debugRefCount > 0;\n  }\n\n  willFocusScene(scene: SharedElementSceneData): void {\n    if (this.debug)\n      console.debug(\n        `[${scene.navigatorId}]willFocus, scene: \"${scene.name}\", depth: ${scene.nestingDepth}, closing: ${this.isTransitionClosing}`\n      );\n    this.registerScene(scene);\n\n    // Wait for a transition start, before starting any animations\n    if (!this.isTransitionStarted) return;\n\n    // Use the animation value from the navigator that\n    // started the transition\n    if (this.prevRoute) {\n      const routeScene = this.isTransitionClosing\n        ? this.getScene(this.prevRoute)\n        : scene;\n      if (routeScene?.navigatorId === this.transitionNavigatorId) {\n        this.routeAnimValue = routeScene?.getAnimValue(\n          this.isTransitionClosing\n        );\n      }\n    }\n\n    // In case of nested navigators, multiple scenes will become\n    // activated. Make sure to use the scene that is nested most deeply,\n    // as this will be the one visible to the user\n    if (!this.route) {\n      this.route = scene.route;\n    } else {\n      const routeScene = this.getScene(this.route);\n      if (routeScene && routeScene.nestingDepth <= scene.nestingDepth) {\n        this.route = scene.route;\n      }\n    }\n\n    // Update transition\n    if (this.prevRoute && this.route && this.routeAnimValue) {\n      this.updateSceneListeners();\n      this.updateSharedElements();\n    }\n  }\n\n  didFocusScene(scene: SharedElementSceneData): void {\n    if (this.debug)\n      console.debug(\n        `[${scene.navigatorId}]didFocus, scene: \"${scene.name}\", depth: ${scene.nestingDepth}`\n      );\n\n    if (!this.route || this.prevRoute) {\n      this.route = scene.route;\n    } else {\n      const routeScene = this.getScene(this.route);\n      if (routeScene && routeScene.nestingDepth <= scene.nestingDepth) {\n        this.route = scene.route;\n      }\n    }\n    this.registerScene(scene);\n  }\n\n  /*willBlurScene(scene: SharedElementSceneData): void {\n    if (this.debug)\n      console.debug(\n        `[${scene.navigatorId}]willBlur, scene: \"${scene.name}\", depth: ${scene.nestingDepth}`\n      );\n\n    // Wait for a transition start, before starting any animations\n    if (!this.isTransitionStarted) return;\n\n    // Use the animation value from the navigator that\n    // started the transition\n    if (\n      this.isTransitionClosing &&\n      scene.navigatorId === this.transitionNavigatorId &&\n      !this.routeAnimValue\n    ) {\n      this.routeAnimValue = scene.getAnimValue(this.isTransitionClosing);\n    }\n\n    // Update transition\n    if (this.prevRoute && this.route && this.routeAnimValue) {\n      this.updateSceneListeners();\n      this.updateSharedElements();\n    }\n  }*/\n\n  private registerScene(scene: SharedElementSceneData) {\n    this.scenes.push({\n      scene,\n      subscription: null,\n    });\n    if (this.scenes.length > 10) {\n      const { subscription } = this.scenes[0];\n      this.scenes.splice(0, 1);\n      subscription?.();\n    }\n    this.updateSceneListeners();\n  }\n\n  private updateSceneListeners() {\n    this.scenes.forEach((sceneRoute) => {\n      const { scene, subscription } = sceneRoute;\n      const isActive =\n        (this.route && this.route.key === scene.route.key) ||\n        (this.prevRoute && this.prevRoute.key === scene.route.key);\n      if (isActive && !subscription) {\n        sceneRoute.subscription = scene.addUpdateListener(() => {\n          // TODO: optimize?\n          this.emitUpdateEvent();\n        });\n      } else if (!isActive && subscription) {\n        sceneRoute.subscription = null;\n        subscription();\n      }\n    });\n  }\n\n  private getScene(\n    route: SharedElementRoute | null\n  ): SharedElementSceneData | null {\n    const sceneRoute = route\n      ? this.scenes.find((sc) => sc.scene.route.key === route.key)\n      : undefined;\n    return sceneRoute ? sceneRoute.scene : null;\n  }\n\n  private updateSharedElements() {\n    const { route, prevRoute, routeAnimValue } = this;\n    const scene = this.getScene(route);\n    const prevScene = this.getScene(prevRoute);\n    const sceneAnimValue = routeAnimValue;\n\n    // Update current scene & previous scene\n    if (\n      scene === this.scene &&\n      prevScene === this.prevScene &&\n      sceneAnimValue === this.sceneAnimValue\n    )\n      return;\n    this.scene = scene;\n    this.prevScene = prevScene;\n    this.sceneAnimValue = sceneAnimValue;\n\n    // Update shared elements\n    let sharedElements: SharedElementsStrictConfig | null = null;\n    let isShowing = true;\n    if (sceneAnimValue && scene && prevScene && route && prevRoute) {\n      sharedElements = getSharedElements(scene, prevScene, true);\n      if (!sharedElements) {\n        isShowing = false;\n        sharedElements = getSharedElements(prevScene, scene, false);\n      }\n    }\n    if (this.sharedElements !== sharedElements) {\n      if (this.debug) {\n        if (sharedElements) {\n          console.debug(\n            `Transition start: \"${prevScene?.name}\" -> \"${\n              scene?.name\n            }\", elements: ${JSON.stringify(sharedElements, undefined, 2)}`\n          );\n        } else {\n          console.debug(`Transition end: \"${scene?.name}\"`);\n        }\n      }\n      this.sharedElements = sharedElements;\n      this.isShowing = isShowing;\n      /*console.log(\n        'updateSharedElements: ',\n        sharedElements,\n        ' ,isShowing: ',\n        isShowing,\n        ', animValue: ',\n        animValue\n      );*/\n      this.emitUpdateEvent();\n    }\n  }\n\n  addUpdateListener(\n    handler: SharedElementRendererUpdateHandler\n  ): SharedElementEventSubscription {\n    this.updateSubscribers.add(handler);\n    return () => this.updateSubscribers.delete(handler);\n  }\n\n  private emitUpdateEvent(): void {\n    this.updateSubscribers.forEach((handler) => handler());\n  }\n\n  getTransitions(): SharedElementTransitionProps[] {\n    const { sharedElements, prevScene, scene, isShowing, sceneAnimValue } =\n      this;\n\n    if (!sharedElements || !scene || !prevScene) return NO_SHARED_ELEMENTS;\n    return sharedElements.map(({ id, otherId, ...other }) => {\n      const startId = isShowing ? otherId || id : id;\n      const endId = isShowing ? id : otherId || id;\n      return {\n        key: scene.route.key,\n        position: sceneAnimValue,\n        start: {\n          ancestor: (prevScene ? prevScene.getAncestor() : undefined) || null,\n          node: (prevScene ? prevScene.getNode(startId) : undefined) || null,\n        },\n        end: {\n          ancestor: (scene ? scene.getAncestor() : undefined) || null,\n          node: (scene ? scene.getNode(endId) : undefined) || null,\n        },\n        ...other,\n      };\n    });\n  }\n\n  get nestingDepth(): number {\n    return 0;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}