{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport hoistNonReactStatics from \"hoist-non-react-statics\";\nimport * as React from \"react\";\nimport View from \"react-native-web/dist/exports/View\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport InteractionManager from \"react-native-web/dist/exports/InteractionManager\";\nimport { nodeFromRef } from \"react-native-shared-element\";\nimport SharedElementSceneContext from \"./SharedElementSceneContext\";\nimport SharedElementSceneData from \"./SharedElementSceneData\";\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1\n  }\n});\n\nfunction isValidNavigationState(state) {\n  return \"index\" in state && \"routes\" in state;\n}\n\nfunction getActiveRoute(state) {\n  var route = state.routes[state.index];\n  var routeState = route.state;\n  return route.state && isValidNavigationState(routeState) ? getActiveRoute(routeState) : route;\n}\n\nfunction isActiveRoute(navigation, route) {\n  var state = navigation.getState ? navigation.getState() : navigation.dangerouslyGetState();\n  var activeRoute = getActiveRoute(state);\n  return route.name === activeRoute.name;\n}\n\nfunction createSharedElementScene(Component, sharedElements, rendererData, emitter, AnimationContext, navigatorId, verbose) {\n  var config = {\n    Component: Component,\n    sharedElements: sharedElements,\n    rendererData: rendererData,\n    AnimationContext: AnimationContext,\n    navigatorId: navigatorId,\n    verbose: verbose\n  };\n\n  var SharedElementSceneView = function (_React$PureComponent) {\n    _inherits(SharedElementSceneView, _React$PureComponent);\n\n    var _super = _createSuper(SharedElementSceneView);\n\n    function SharedElementSceneView() {\n      var _this;\n\n      _classCallCheck(this, SharedElementSceneView);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _super.call.apply(_super, [this].concat(args));\n      _this.subscriptions = {};\n      _this.sceneData = new SharedElementSceneData(Component, function () {\n        return config.sharedElements || Component.sharedElements;\n      }, _this.props.route, navigatorId, rendererData.nestingDepth, verbose);\n\n      _this.onTransitionStart = function (event) {\n        var closing = event.data.closing;\n        rendererData.startTransition(closing, navigatorId, rendererData.nestingDepth);\n      };\n\n      _this.onTransitionEnd = function (_ref) {\n        var closing = _ref.data.closing;\n        rendererData.endTransition(closing, navigatorId, rendererData.nestingDepth);\n      };\n\n      _this.onRenderAnimationContext = function (value) {\n        _this.sceneData.setAnimimationContextValue(value);\n\n        return null;\n      };\n\n      _this.onSetRef = function (ref) {\n        _this.sceneData.setAncestor(nodeFromRef(ref));\n      };\n\n      _this.onWillFocus = function () {\n        var _this$props = _this.props,\n            navigation = _this$props.navigation,\n            route = _this$props.route;\n\n        if (isActiveRoute(navigation, route)) {\n          _this.sceneData.updateRoute(route);\n\n          rendererData.updateSceneState(_this.sceneData, \"willFocus\");\n          InteractionManager.runAfterInteractions(function () {\n            _this.sceneData.updateRoute(_this.props.route);\n\n            rendererData.updateSceneState(_this.sceneData, \"didFocus\");\n          });\n        }\n      };\n\n      _this.onWillBlur = function () {\n        var route = _this.props.route;\n\n        _this.sceneData.updateRoute(route);\n      };\n\n      return _this;\n    }\n\n    _createClass(SharedElementSceneView, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var navigation = this.props.navigation;\n        this.subscriptions = {\n          willFocus: emitter.addListener(\"focus\", this.onWillFocus),\n          willBlur: emitter.addListener(\"blur\", this.onWillBlur),\n          transitionStart: navigation.addListener(\"transitionStart\", this.onTransitionStart),\n          transitionEnd: navigation.addListener(\"transitionEnd\", this.onTransitionEnd)\n        };\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        Object.values(this.subscriptions).forEach(function (unsubscribe) {\n          return unsubscribe();\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return React.createElement(SharedElementSceneContext.Provider, {\n          value: this.sceneData\n        }, React.createElement(View, {\n          style: styles.container,\n          collapsable: false,\n          ref: this.onSetRef\n        }, React.createElement(AnimationContext.Consumer, null, this.onRenderAnimationContext), React.createElement(Component, _objectSpread({}, this.props))));\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate() {\n        this.sceneData.updateRoute(this.props.route);\n      }\n    }]);\n\n    return SharedElementSceneView;\n  }(React.PureComponent);\n\n  SharedElementSceneView.config = config;\n  hoistNonReactStatics(SharedElementSceneView, Component);\n  return SharedElementSceneView;\n}\n\nexport default createSharedElementScene;","map":{"version":3,"sources":["../src/createSharedElementScene.tsx"],"names":[],"mappings":"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","sourcesContent":["import { Route, NavigationState } from \"@react-navigation/native\";\nimport {\n  StackNavigationProp,\n  StackCardInterpolationProps,\n} from \"@react-navigation/stack\";\nimport hoistNonReactStatics from \"hoist-non-react-statics\";\nimport * as React from \"react\";\nimport { View, StyleSheet, InteractionManager } from \"react-native\";\nimport { nodeFromRef } from \"react-native-shared-element\";\n\nimport { ISharedElementRendererData } from \"./SharedElementRendererData\";\nimport SharedElementSceneContext from \"./SharedElementSceneContext\";\nimport SharedElementSceneData from \"./SharedElementSceneData\";\nimport {\n  SharedElementEventSubscription,\n  SharedElementSceneComponent,\n  SharedElementRoute,\n  SharedElementsComponentConfig,\n} from \"./types\";\nimport { EventEmitter } from \"./utils/EventEmitter\";\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n});\n\ntype PropsType = {\n  navigation: StackNavigationProp<any>;\n  route: SharedElementRoute;\n};\n\nfunction isValidNavigationState(\n  state: Partial<NavigationState>\n): state is NavigationState {\n  return \"index\" in state && \"routes\" in state;\n}\n\n// Gets the current screen from navigation state\nfunction getActiveRoute(state: NavigationState): Route<any> {\n  const route = state.routes[state.index];\n  const routeState = route.state as Partial<NavigationState>;\n  return route.state && isValidNavigationState(routeState)\n    ? getActiveRoute(routeState) // Dive into nested navigators\n    : route;\n}\n\nfunction isActiveRoute(\n  navigation: StackNavigationProp<any>,\n  route: Route<any>\n): boolean {\n  // @ts-ignore: getState is supported by navigation 6\n  const state: NavigationState = navigation.getState\n    ? // @ts-ignore: getState is supported by navigation 6\n      navigation.getState()\n    : // @ts-ignore: dangerouslyGetState is provided for navigation 5 compatibility\n      navigation.dangerouslyGetState();\n  const activeRoute = getActiveRoute(state);\n  return route.name === activeRoute.name;\n}\n\nfunction createSharedElementScene(\n  Component: SharedElementSceneComponent,\n  sharedElements: SharedElementsComponentConfig | void,\n  rendererData: ISharedElementRendererData,\n  emitter: EventEmitter,\n  AnimationContext: React.Context<StackCardInterpolationProps | undefined>,\n  navigatorId: string,\n  verbose: boolean\n): React.ComponentType<any> {\n  const config = {\n    Component,\n    sharedElements,\n    rendererData,\n    AnimationContext,\n    navigatorId,\n    verbose,\n  };\n\n  class SharedElementSceneView extends React.PureComponent<PropsType> {\n    private subscriptions: {\n      [key: string]: SharedElementEventSubscription;\n    } = {};\n    private sceneData: SharedElementSceneData = new SharedElementSceneData(\n      Component,\n      () => config.sharedElements || Component.sharedElements,\n      this.props.route,\n      navigatorId,\n      rendererData.nestingDepth,\n      verbose\n    );\n\n    static readonly config = config;\n\n    componentDidMount() {\n      const { navigation } = this.props;\n      this.subscriptions = {\n        willFocus: emitter.addListener(\"focus\", this.onWillFocus),\n        willBlur: emitter.addListener(\"blur\", this.onWillBlur),\n        transitionStart: navigation.addListener(\n          \"transitionStart\",\n          this.onTransitionStart\n        ),\n        transitionEnd: navigation.addListener(\n          \"transitionEnd\",\n          this.onTransitionEnd\n        ),\n      };\n    }\n\n    private onTransitionStart = (event: any) => {\n      const closing: boolean = event.data.closing;\n      rendererData.startTransition(\n        closing,\n        navigatorId,\n        rendererData.nestingDepth\n      );\n      //rendererData.updateSceneState(this.sceneData, \"willFocus\");\n    };\n\n    private onTransitionEnd = ({ data: { closing } }: any) => {\n      rendererData.endTransition(\n        closing,\n        navigatorId,\n        rendererData.nestingDepth\n      );\n    };\n\n    componentWillUnmount() {\n      Object.values(this.subscriptions).forEach((unsubscribe) => unsubscribe());\n    }\n\n    render() {\n      // console.log('SharedElementSceneView.render');\n      return (\n        <SharedElementSceneContext.Provider value={this.sceneData}>\n          <View\n            style={styles.container}\n            collapsable={false}\n            ref={this.onSetRef}\n          >\n            <AnimationContext.Consumer>\n              {this.onRenderAnimationContext}\n            </AnimationContext.Consumer>\n            <Component {...this.props} />\n          </View>\n        </SharedElementSceneContext.Provider>\n      );\n    }\n\n    private onRenderAnimationContext = (\n      value: StackCardInterpolationProps | undefined\n    ) => {\n      this.sceneData.setAnimimationContextValue(value);\n      return null;\n    };\n\n    componentDidUpdate() {\n      this.sceneData.updateRoute(this.props.route);\n    }\n\n    private onSetRef = (ref: any) => {\n      this.sceneData.setAncestor(nodeFromRef(ref));\n    };\n\n    private onWillFocus = () => {\n      const { navigation, route } = this.props;\n\n      //console.log(\"onWillFocus: \", route);\n      if (isActiveRoute(navigation, route)) {\n        this.sceneData.updateRoute(route);\n        rendererData.updateSceneState(this.sceneData, \"willFocus\");\n        InteractionManager.runAfterInteractions(() => {\n          //console.log(\"onDidFocus: \", this.props.route);\n          this.sceneData.updateRoute(this.props.route);\n          rendererData.updateSceneState(this.sceneData, \"didFocus\");\n        });\n      }\n    };\n\n    private onWillBlur = () => {\n      const { route } = this.props;\n\n      //console.log(\"onWillBlur: \", route);\n      this.sceneData.updateRoute(route);\n      //rendererData.updateSceneState(this.sceneData, \"willBlur\");\n    };\n  }\n\n  hoistNonReactStatics(SharedElementSceneView, Component);\n  return SharedElementSceneView;\n}\n\nexport default createSharedElementScene;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}